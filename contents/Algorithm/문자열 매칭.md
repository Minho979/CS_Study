# 문자열 매칭
텍스트 문자열 A[1...n]이 패턴 문자열 P[1...m]을 포함하는지를 알아보고 포함하는 경우 어느 위치에 있는지를 알아내는 알고리즘
- n > m
- 예시) A = "aababacccc", P = "aba"

  매칭이 일어난 위치(매칭된 A의 시작 인덱스): 2, 4 (인덱스의 시작을 1로 설정)

## 원시적인(naive) 매칭
### 작동 원리
- 문자열을 처음부터 끝까지 하나하나 비교한다.

- 예시 

  <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/naiveMatching.jpeg' width='500'>
### 시간 복잡도
- 문자열을 처음부터 끝까지 비교하기에 $O(MN)$
### 비효율적인 이유
- 앞선 매칭 과정에서 얻은 정보를 전혀 이용하지 않으므로 비효율적이다.

- 예시

  <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/naiveMatching2.jpeg' width='500'>

  - 1에서 불일치로 중단하지만 P의 앞부분 abc가 A의 두번째 abc와 일치한다는 사실을 활용한다면 2, 3, 4의 과정은 불필요하다.

### 의사 코드 
``` java
naiveMatching(A[], P[]) {
    n = A.length;
    m = P.length;
    
    for (i = 1; i < n - m + 1; ++i) {
      for (j = 1; j < m + 1; ++j) {
          if (P[j] == A[i + j - 1])
              return true;
      }
    }
    return false;
}
```

## 오토마타를 이용한 매칭
- 유한 오토마타(finite automata)를 이용
  - 문제 해결 절차를 상태 전이(state transition)로 나타냄
  - 구성 요소: ($Q, q_0, F, ∑, δ$)
    - $Q$: 상태 집합
    - $q_0$: 시작 상태
    - $F$: 목표 상태(최종 상태)들의 집합
    - $∑$: 입력 알파벳
    - $δ$: 상태 전이 함수 ($Q×∑ → Q$)
  - 예시)
 
    <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/finite-automata.png' width='500'>

### 오토마타를 이용한 매칭 단계
### 1. 전처리 작업 단계(preprocessing)
- 찾고자 하는 패턴에 대해 오토마타를 정의
- P[1...m] → 하나의 오토마타 (1 패턴 = 1 오토마타)
  - 매칭이 어디까지 진행되었는가를 상태로 표현
  - 어떤 경우 어떤 상태로 전이하는가를 정의
- 예

  <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/automata-preprocessing.png' width='650'>

### 2. 매칭 단계(matching)
- 시작 상태에서 시작하여 텍스트 문자열의 문자를 하나씩 읽어 그 문자에 맞게 상태 전이
  - 최종 상태에 이른 경우 매칭된 것
- 이어서 텍스트 문자열을 계속해서 읽고 상태 전이도 계속 진행함
- 매칭 알고리즘
``` java
FA-Matcher(A, δ, f) {  // f: 목표 상태
    q = 0;    // 0: 시작 상태
    for (i = 1; i < n; ++i) {  // n: 배열 A[]의 길이
        q = δ(q, A[i]);
        if (q == f) {
            match = A[i - m + 1];
            return true;
        }
    }
    return false;
}
```

### 시간 복잡도 
- 상태전이함수 구성 시간: $O(|∑|m)$
  - 위의 시간은 상태전이함수가 가장 효율적이라고 볼 때의 시간
- 매칭 알고리즘 수행 시간: $O(n)$
- 오토마타를 이용한 매칭 총 수행시간: $O(n + |∑|m)$

## Rabin-Karp 알고리즘
- 문자열 패턴을 수치로 바꾸어 문자열의 비교를 수치로 대신하는 알고리즘
- 수치화
  - 가능한 문자 집합 Σ의 크기에 따라 진수가 결정
  - 예시 1)
    - Σ = {a, b, c, d, e, f, g, h, i, j}
    - |Σ| = 10
    - 위의 두 가지를 활용해 진법을 결정
    - 문자 a, b, c, ..., j를 각각 0, 1, 2, ..., 9에 대응
    - 문자열 "cad"를 수치화하면 ${2\*10^2+0\*10^1+3\*10^0 = 203}$
  - 예시 2)
    - Σ = {a, b, c, d, e}
    - |Σ| = 5
    - a, b, c, d, e를 각각 0, 1, 2, 3, 4에 대응
    - 문자열 "cad"를 수치화 ${2\*5^2+0\*5^1+3\*5^0 = 53}$
    - 문자열 "bec"를 수치화 ${1\*5^2+4\*5^1+2\*5^0 = 47}$
    - 문자열 "eca"를 수치화 ${4\*5^2+2\*5^1+0\*5^0 = 110}$
    - A = "becad" P="cad"인 경우
      - `47 != 53`, `110 != 53`, `53 == 53` 매칭이 가능하다.

### 해결해야 하는 문제점 
- 수치화 작업의 부담
  - 
- 수치가 커져 오버플로우 발생 가능성

## KMP 알고리즘
## Boyer-Moore-Horspool 알고리즘







> ⬆️:[Top](#문자열-매칭)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Algorithm)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [문병로. 쉽게 배우는 알고리즘. 한빛아카데미]
