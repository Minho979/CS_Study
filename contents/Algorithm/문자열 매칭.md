# 문자열 매칭
텍스트 문자열 A[1...n]이 패턴 문자열 P[1...m]을 포함하는지를 알아보고 포함하는 경우 어느 위치에 있는지를 알아내는 알고리즘
- n > m
- 예시) A = "aababacccc", P = "aba"

  매칭이 일어난 위치(매칭된 A의 시작 인덱스): 2, 4 (인덱스의 시작을 1로 설정)

## 원시적인(naive) 매칭
### 의사 코드 
``` java
naiveMatching(A[], P[]) {
    n = A.length;
    m = P.length;
    
    for (i = 1; i < n - m + 1; ++i) {
      for (j = 1; j < m + 1; ++j) {
          if (P[j] == A[i + j - 1])
              return true;
      }
    }
    return false;
}
```
### 작동 원리
- 문자열을 처음부터 끝까지 하나하나 비교한다.

- 예시 
  
### 시간 복잡도
- 문자열을 처음부터 끝까지 비교하기에 $O(MN)$
### 비효율적인 이유
- 앞선 매칭 과정에서 얻은 정보를 전혀 이용하지 않으므로 비효율적이다.

- 예시

  - 1에서 불일치로 중단하지만 P의 앞부분 abc가 A의 두번째 abc와 일치한다는 사실을 활용한다면 2, 3, 4의 과정은 불필요하다.


## 오토마타 
## Rabin-Karp 알고리즘
## KMP 알고리즘
## Boyer-Moore-Horspool 알고리즘







> ⬆️:[Top](#문자열-매칭)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Algorithm)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [문병로. 쉽게 배우는 알고리즘. 한빛아카데미]
