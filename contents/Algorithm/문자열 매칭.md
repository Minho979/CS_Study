# 문자열 매칭
텍스트 문자열 A[1...n]이 패턴 문자열 P[1...m]을 포함하는지를 알아보고 포함하는 경우 어느 위치에 있는지를 알아내는 알고리즘
- n > m
- 예시) A = "aababacccc", P = "aba"

  매칭이 일어난 위치(매칭된 A의 시작 인덱스): 2, 4 (인덱스의 시작을 1로 설정)

## 원시적인(naive) 매칭
### 의사 코드 
``` java
naiveMatching(A[], P[]) {
    n = A.length;
    m = P.length;
    
    for (i = 1; i < n - m + 1; ++i) {
      for (j = 1; j < m + 1; ++j) {
          if (P[j] == A[i + j - 1])
              return true;
      }
    }
    return false;
}
```
### 작동 원리
- 문자열을 처음부터 끝까지 하나하나 비교한다.

- 예시 

  <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/naiveMatching.jpeg' width='500'>
### 시간 복잡도
- 문자열을 처음부터 끝까지 비교하기에 $O(MN)$
### 비효율적인 이유
- 앞선 매칭 과정에서 얻은 정보를 전혀 이용하지 않으므로 비효율적이다.

- 예시

  <img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/naiveMatching2.jpeg' width='500'>

  - 1에서 불일치로 중단하지만 P의 앞부분 abc가 A의 두번째 abc와 일치한다는 사실을 활용한다면 2, 3, 4의 과정은 불필요하다.

## 오토마타를 이용한 매칭
- 유한 오토마타(finite automata)를 이용
  - 문제 해결 절차를 상태 전이(state transition)로 나타냄
  - 구성 요소: ($Q, q_0, F, ∑, δ$)
    - $Q$: 상태 집합
    - $q_0$: 시작 상태
    - $F$: 목표 상태(최종 상태)들의 집합
    - $∑$: 입력 알파벳
    - $δ$: 상태 전이 함수 ($Q×∑ → Q$)
  - 예시) 

### 오토마타를 이용한 매칭 단계
### 1. 전처리 작업 단계(preprocessing)
- 찾고자 하는 패턴에 대해 오토마타를 정의
- P[1...m] → 하나의 오토마타 (1 패턴 = 1 오토마타)
  - 매칭이 어디까지 진행되었는가를 상태로 표현
  - 어떤 경우 어떤 상태로 전이하는가를 정의

### 2. 매칭 단계(matching)

## Rabin-Karp 알고리즘
## KMP 알고리즘
## Boyer-Moore-Horspool 알고리즘







> ⬆️:[Top](#문자열-매칭)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Algorithm)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [문병로. 쉽게 배우는 알고리즘. 한빛아카데미]
