# 프로세스와 스레드
초기 컴퓨터는 하나의 프로그램이 프로세서를 독점했고 프로세스를 통한 관리가 필요하지 않았다.  
하지만 다중 프로그래밍에서 여러 프로그램이 자원을 공유하기에 프로그램들을 제어하는 방법이 요구되었다.  
이에 프로세스를 이용한 프로그램 제어 및 관리를 통해 멀티태스킹 기능을 실현하였다. 

## 프로세스의 개념
<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/program-process.png' width='500'>

- 프로세스는 메모리에 적재되어 실행되고 있는 프로그램의 인스턴스(독립적인 개체)로 운영체제의 제어를 받는 상태를 의미한다.  
즉, 프로세스는 실행 중인 프로그램의 실행 단위로 볼 수 있다.  
- 프로그램이 실행되면 메모리에 적재되고 운영체제로부터 시스템 자원(CPU 시간, 주소 공간, 메모리 영역)을 할당 받는다.  
- 프로세스는 실행 중 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성하는데 이 과정에서 부모 프로세스, 자식 프로세스가 생기며 계층 구조를 형성한다.
### 프로세스의 주소 공간
프로세스가 실행 중 접근할 수 있도록 허용된 주소의 최대 범위를 말하며, 프로세스의 주소 공간은 CPU 주소 공간과 같다.
#### 프로세스 주소 공간 구조 
프로세스 주소 공간은 사용자 공간과 커널 공간 전체를 포함하며 CPU가 액세스 할 수 있는 전체 공간이 프로세스의 주소 공간이다.

프로세스의 주소 공간에서 힙과 스택 영역의 크기는 정해져 있지 않고, 코드와 데이터를 뺀 나머지 공간을 둘이 합쳐 사용한다.
- 힙: 데이터 영역이 끝난 영역에서 시작하여 주소가 큰 방향으로 커진다.
- 스택: 사용자 주소 공간의 끝에서 주소가 작은 방향으로 커진다.

프로세스는 운영체제에서 설정한 사용자 공간의 최대 범위까지 힙 영역과 스택 영역을 늘려갈 수 있다.

시스템 호출을 통해 커널 공간까지 접근 할 수 있다.

프로세스의 크기와 프로세스 주소 공간 크기는 다르다.
- 프로세스 주소 공간 크기: 프로세스가 액세스 할 수 있는 전체 영역
- 프로세스의 크기: 프로세스가 주소 공간 내에서 현재 사용하고 있는 코드, 데이터, 힙, 스택을 합친 크기

#### 프로세스 주소 공간 구성
<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-structure.png' width='600'>

- 실행 스택(stack)
  - 호출된 함수(프로시저)의 복귀 주소와 지역 변수 등의 일시적인(함수 실행을 위해 필요한) 데이터를 저장하는 영역
  - 프로세스의 실행 시 사용되는 영역으로, 함수 호출 시 매개변수들과 전역 변수 등을 저장한다.
  - 함수가 종료되면 해당 함수에 의해 할당된 변수들은 메모리에서 해제된다.
  - 함수와 지역 변수 등은 스레드마다 공간을 할당한 Stack구조를 통해 사용이 종료됨에 따라 해제하는 등의 제어가 용이하다.
  - 높은 주소에서 낮은 주소로 할당된다.
  - Stack 메모리 영역을 넘어서 할당되는 경우 Stack Overflow가 발생한다. 
- 실행 힙(heap)
  - 시스템 호출을 통해 동적으로 할당받고 해지하는 등 자유롭게 이용하는 영역으로 런타임에 크기가 결정된다.
  - 주로 참조형 데이터(Class 등)의 데이터가 할당된다.
  - 낮은 주소에서 높은 주소로 할당된다.
  - Heap 메모리 영역을 넘어서 할당되는 경우 Heap Overflow가 발생한다. 
- 데이터(data)
  - 실행 파일 내에 구성된 전역 변수, 정적 변수 등이 저장되는 영역
  - main 함수가 실행되는 동안 메모리 상에 남아있는 변수들을 저장한다.
  - 전역변수 자원을 저장하고 스레드들이 공유하도록하여 효율성을 높인다.
  - 초기화된 데이터 영역(initialized data segment)과 초기화되지 않은 데이터 영역(uninitialized data segment)으로 나뉜다.
- 코드(code)
  - 텍스트 영역이라고도 불린다.
  - 실행 파일 내 구성된 코드들이 적재되는 영역으로 프로그램을 실행시키기 위한 명령문들(제어문, 함수, 상수)이 저장된다.
  - CPU가 해석이 가능한 기계어로 저장되고, 프로그램이 수정되면 안되기에 Read-Only 상태로 저장된다.   

### 프로세스의 종류 
역할과 병행 수행 방법에 따라 구분된다. 
#### 역할에 의한 구분
크게 두 개의 프로세스로 구분되며 두 프로세서 모두 메모리에서 프로그램을 실행한다.  
- 시스템(커널) 프로세스
  - 커널 프로세스 또는 운영체제 프로세스라고 부른다.
  - 모든 시스템 메모리에 접근하고, 모든 프로세서 명령을 실행할 수 있는 프로세스이다.
  - 시스템 운영에 필요한 작업을 수행한다.
- 사용자 프로세스
  - 사용자 코드를 수행하는 프로세스로 시스템 프로세스에 비해 권한이 적다.
  - 자기 자신에게 할당된 공간만 접근 가능하며 특정 프로세서 명령어는 실행이 불가능하다.
    - 시스템에 중요한 영향을 주는 명령어는 실행이 불가능하다.
  - 사용자 프로세스가 실행할 수 없는 프로세서 명령어는 시스템 호출을 통해 처리한다. 

#### 병행 수행 방법에 의한 구분
- 독립 프로세스
  - 여러개의 프로세스가 각자 동시에 실행 되며 병행 프로세스들이 서로 영향을 주고 받지 않는다.
  - 데이터를 공유하지 않는다.

- 협력 프로세스
  - 병행 프로세스들이 서로 영향을 주고 받는다.
  - 제한된 자원을 공유하는 등 서로 협력해야하는 경우 통신을 위한 수단과 동기화 기능이 필요하다.

## 프로세스의 상태 변화
프로세스 상태는 크게 3가지로 분류된다. 

<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-state.png' width='500'>

- 실행(running)
  - 프로세서를 점유하여 명령어가 실행되는 상태이다.
- 준비(ready)
  - 프로세서를 할당 받기 위해 기다리는 상태로 실행을 위하단 다른 조건을 갖추고 준비 리스트에서 자신의 차례를 기다린다.
  - 준비 리스트는 큐를 사용한다. 
- 대기(waiting) 또는 보류(blocked)
  - 이벤트(입출력 종료 등 외부 신호) 발생을 기다리는 상태로 장치 별로 대기 큐를 가진다.  

<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-state-change.png' width='600'>

대부분의 프로세스는 준비나 대기(보류) 상태로 존재하며 어느 한 순간에 한 프로세스만 실행 상태로 상태 변화가 일어난다.  
상태 변화는 4가지가 있다. 
#### dispatch(프로세스 이름)
준비 → 실행
- 준비 상태의 프로세스가 프로세서를 할당 받아 실행 상태가 된다.
- 프로세스 스케줄러는 준비 상태인 프로세스 중 하나를 선택하고 디스패처(dispatcher)는 선택된 프로세스에 프로세서를 할당한다.
#### timeout(프로세스 이름)
실행 → 준비
- 실행 상태의 프로세스가 프로세서를 자발적으로 반납하기 전에 할당된 시간이 지나면 해당 프로세스를 준비 상태가 된다.
- 인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 프로세서를 독점하는 것을 방지한다.  
  인터럽트 클록: 프로세스가 프로세서를 할당 받은 후 일정 시간이 지나면 자원의 독점을 막기위해 자동으로 인터럽트를 발생시킨다. 
#### block(프로세스 이름)
실행 → 대기(보류)
- 실행 상태의 프로세스가 자신에게 할당된 시간이 끝나기 전에 어떠한 이벤트가 발생하는 것을 기다려야할 때 스스로 프로세서를 양도하고 대기 상태가 된다.
- 이벤트: 입출력 요청, 새로운 자원 요청 등
#### wakeup(프로세스 이름)
대기(보류) → 준비
- 기다리던 조건이 만족(기다리던 이벤트 발생)되면 대기 상태의 프로세스는 준비 상태가 된다. 

## 프로세스의 관리
### 프로세스 제어 블록(PCB: Process Control Block)
- 운영체제가 각 프로세스를 관리하기 위해 필요한 정보(메타 데이터)를 저장해두는 자료 구조로 하나의 PCB에 하나의 프로세스 정보가 담긴다.
- 커널 시스템은 하나의 프로세스 테이블을 통해 모든 프로세스를 관리하며 프로세를 생성할 떄마다 PCB를 생성하여 프로세스 정보를 저장한다.
- 프로세스 테이블의 비어있는 항목에 PID(프로세스 번호)와 함께 PCB를 연결하고 PID로 프로세스를 구분한다.
- 작업 제어 블록(Task Control Block)이라고도 불린다.

#### PCB의 생성과 제거
- 생성
  - 프로세스가 생겨나고 프로세스 주소 공간에 코드, 데이터, 스택 공간이 생성된 후 PCB가 생성되며 프로세스 정보가 저장된다.
  - 생성된 PCB는 메인 메모리에 유지된다.
- 제거
  - 프로세스가 종료되면 같이 제거된다.
 
#### PCB에 저장되는 프로세스의 정보
- 프로세스 식별자(Process ID): 프로세스 고유 식별 번호
- 프로세스 상태(Process State): 프로세스의 현재 상태 정보((create), 준비(ready), 실행(running), 대기(waiting), 완료(terminated))
- 프로그램 카운터(Program Counter): 프로세스가 다음에 실행할 명령어의 주소
- 레지스터 저장 영역: 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터, 조건 코드 등 정보  
   - 인터럽트 발생 시 프로그램 카운터와 함께 저장하여 재실행 시 원래대로 복귀할 수 있도록 한다.
- 프로세서 스케줄링 정보: 프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수, CPU 점유시간 등 정보
- 메모리 관리 정보: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관리 시스템 정보
- 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등 프로세스 정보 
- 입출력 상태 정보: 특별한 입출력 요구 프로세스에 할당된 입출력 장치, 열린 파일 리스트 등에 관한 정보

#### PCB가 존재하는 이유 
인터럽트를 통해 여러 프로세스를 실행하는 경우, 유실된 정보 없이 실행하기 위해 대기 중인 프로세스의 직전 정보와 상태를 저장하는 프로세스 제어 블록이 필요하다.   
커널은 현재 CPU가 실행 중인 프로세스를 중단 시키고 다른 프로세스를 실행할 때, 현재 프로세스가 실행 중인 상황 정보를 PCB에 저장한다.

#### 프로세스 스케줄링
- 연결리스트 방식으로 관리하여 삽입 및 삭제가 용이하다.
- PCB List Head에 PCB가 생성될 때마다 이어지게 만든다.
- 프로세스가 생성되면 Ready Queue에 삽입되지만 실제로는 PCB가 연결리스트로 연결되어 있다.

### 프로세스 생성
운영체제 또는 다른 프로세스의 요청에 의해 프로세스가 생성된다.  
- 프로세스의 생성 과정
  1. 새로운 프로세스에 프로세스 식별자 할당
  2. 프로세스의 주소 공간과 프로세스 제어 블록 할당
  3. 프로세스 제어 블록 초기화
  4. Ready Queue에 삽입
- 자원 할당
  - 자식 프로세스에게 필요한 자원을 운영체제가 직접 할당
  - 자식 프로세스가 부모 프로세스의 자원 일부 사용
- 실행 방식
  - 부모 프로세스와 자식 프로세스가 동시에 실행
  - 부모 프로세스는 자식 프로세스들이 모두 종료할때까지 기다린다
- 주소 공간
  - 동일 작업을 수행할 경우 자식 프로세스가 부모 프로세스의 주소 공간을 복사
  - 다른 작업을 수행할 경우 자식 프로세스가 별도의 프로그램을 적재
### 프로세스 종료
프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스 제거를 요청하며 부모 프로세스가 자식 프로세스를 종료할 수 있다.  
이 경우 부모 프로세스가 abort(중단) 시스템을 호출하여 자식 프로세스를 종료한다.  
보통 부모 프로세스를 종료하면 운영체제가 자식 프로세스도 종료하는데 이를 연속 종료라고 한다. 
- 프로세스 종료 이유
  - 정상 종료
  - 명시된 전체 시간 초과
  - 실패: 파일 검색 실패, 입출력 실패 등
  - 오류 발생
  - 메모리 부족, 접근 위반 등
### 프로세스 제거
프로세스 종료 후 프로세스를 파괴하는 과정으로 프로세스가 점유하고 있던 자원을 시스템에 반납하고 해당 프로세스가 시스템 리스트나 테이블에서 제거된다.(PCB 제거)  
부모 프로세스를 제거하면 자식 프로세스도 같이 제거된다.  
프로그램은 여전히 디스크에 저장되어 있다. 

### 프로세스 중단(suspend)과 재시작(resume)

<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-state-change2.png' width='600'>

프로세스의 상태 변화에 중단과 재시작이 추가된 상태 변화로 보조기억장치에 우선순위가 낮은 프로세스를 이동시켰다가 활동 시 다시 메인 메모리로 복귀시킨다. 
- 중단과 재시작을 추가한 프로세스의 상태 변화
- 두 가지의 중단 상태
  - 중단된 대기(suspended waiting): 프로세스가 보조기억장치에 있으면서 이벤트를 대기 중인 상태
  - 중단된 준비(suspended ready): 프로세스가 보조기억장치에 있지만 즉시 메인 메모리로 로드하여 실행할 수 있는 상태
- 프로세스 중단과 재시작 발생 상황
  - 시스템 부하 조정이 필요할 때
  - 시스템 기능 장애가 발생할 때
  - 프로세스의 일부분이 의심스러울 때
  - 주기적 프로세스가 다음 실행을 기다릴 때
  - 부모 프로세스가 자식 프로세스를 조사 또는 수정하여 활동을 재조정할 때
### 프로세스 우선순위 변경 
프로세스는 서로 다른 우선순위를 가질 수 있으며 프로세스 스케줄러는 PCB에 기록된 우선 순위를 이용하여 Ready Queue의 프로세스를 처리한다.
- 우선 순위 구분
  - 프로세서 중심 프로세스(CPU-bound process)
    - 주로 CPU를 이용한 연산이 많으며 입출력이 적다.
    - 프로세서를 한 번 차지하면 오래 사용하는 경향이 있다.
    - 시간 할당량을 길게하여 프로세서 사용 횟수를 줄이고 한 번에 오래 사용한다.
    - 낮은 우선순위가 부여된다.
  - 입출력 중심 프로세스(I/O-bound process)
    - CPU의 사용은 적고 입출력을 자주 받는다.
    - 프로세서를 한번 차지하면 짧게 사용하는 경향이 있다.
    - 높은 우선순위가 부여된다.

### 문맥 교환
원래 실행중이던 프로세스의 정보를 PCB에 저장하고, 바뀌는 프로세스의 정보를 PCB에 저장된 내용을 토대로 레지스터에 적재하여 프로세스를 교환하는 과정이다.  
여러 프로세스를 동시에 수행하는 것처럼 보이게 하기 위해 사용되며 운영체제 설계시 불필요한 문맥 교환을 줄이는 것이 주요 목표이다. 
- Why? 문맥 교환은 시간과 비용이 들어가는 오버헤드로 자주 일어나는 경우 시스템 전체 성능 저하가 발생할 수 있다.  
  오버헤드: 어떤 처리를 위해 소모되는 간접적인 처리 시간 메모리 등을 뜻하며 메모리 속도, 레지스터 수, 특수 명령어의 유무에 따라 오버헤드가 다르다.

<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-context-swithching.png' width='500'>
<img src='https://github.com/Minho979/CS_Study/blob/main/contents/images/process-context-swithching-ex.png' width='500'>

- 사용자 모드에서 커널 모드로 넘어와 수행하는 것들이 오버헤드에 해당한다.

#### 문맥 교환이 발생하는 경우
  - 인터럽트
    - 입출력 인터럽트: 입출력 관련 인터럽트로 입출력 완료에 의해 발생 
    - 클록 인터럽트: CPU가 특정 프로세스에 집중적으로 사용이 안되도록 관리(Timeout)
    - 트랩(trap): 소프트웨어적 인터럽트로 부정적 파일 접근 또는 실행중인 프로세스의 오류나 예외 상황으로 인해 발생
  - 프로세스의 선점시간이 종료되는 경우
  - 입출력 등 특정한 이벤트를 위해 대기하는 경우 

## 스레드의 개념과 상태변화
스레드(thread)는 프로세서를 사용하는 기본단위로 명령어를 독립적으로 실행할 수 있는 하나의 제어흐름이다.  
프로세스는 자원과 제어로 구성되어 있는데 이 중 실행 제어를 분리한 실행 단위가 스레드이다. 
일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고, 하나의 프로세스는 반드시 하나 이상의 스레드를 가진다.  

### 스레드의 특징 
- 스레드는 프로세스 내에서 각각 스택을 따로 할당받고, 코드, 데이터, 힙 영역은 같은 프로세스 내의 스레드들과 공유한다.
- 각 스레드는 스레드 실행 정보(레지스터, 스레드 우선순위, 스레드 상태), 실행 스택을 가지며 각자의 정보를 저장한다.
- 모든 스레드는 논리적으로 프로세스에 포함되며 개별적으로 존재할 수 없다.
- 한 스레드가 프로세스의 자원을 변경하는 경우, 다른 이웃 스레드(sibling thread)도 변경 결과를 즉시 확인할 수 있다.
- 프로세스에 비해 생성과 종료 등이 가볍고 빠르다. 
- 스레드는 동일한 주소 공간을 공유하며 서로 직접 통신할 수 있다.

  - 서로 실행하고 있는 부분이 다를 수 있기 대문에 각 스레드마다 각각의 PC, Stack를 가진다.

### 스레드의 상태변화 
프로세스와 마찬가지로 생성, 준비, 실행, 대기, 종료 상태를 가진다. 

- 실행 스레드가 대기 상태로 변화하더라도 스레드가 속한 프로세스 전체가 대기 상태가 되는 것이 아니기에 해당 프로세스의 다른 스레드는 실행이 가능하다. 

### 스레드 제어 블록(Thread Control Block)
운영체제는 각 스레드를 관리하기 위해 필요한 스레드 정보를 저장한다.  
각 스레드마다 하나의 TCB가 생성되고 한 프로세스에 속한 TCB들이 TCB 리스트를 구성한다. TCB 리스트는 PCB가 가리키고 있다. 

- TCB의 구성
  - 스레드 ID
  - 레지스터 값
  - 프로그램 카운터
  - 스택 포인터
  - 스케줄러 정보: 상태(실행, 준비, 대기), 우선순위, 프로세서 시간 등
  - 스레드가 속한 프로세스의 PCB에 대한 모니터 

## 스레드의 구현
### 사용자 수준 스레드(user-level-thread)
- 커널 스레드를 지원하지 않는 운영체제에서 사용한다.
- 커널은 스레드가 아닌 프로세스를 하나의 단위로 인식하여 스케줄링하며, 하나의 상태를 할당한다.
- 여러 사용자 수준 스레드들이 하나의 커널 스레드(프로세스)로 매핑되므로 다대일 스레드 매핑이 일어난다.
- 사용자 영역의 스레드 라이브러리를 통해 작동한다.
  - 스레드 라이브러리: 스레드와 관련된 모든 연산을 구현하고, 스레드의 생성과 종료, 스레드 간의 메시지 전달, 스레드 스케줄링, 문맥 등 정보를 보관한다.
  - POSIX 표준안의 스레드 확장판인 Pthread, Win32 스레드, 자바 스레드 API 등이 주로 사용한다.
- 스레드와 모든 행위를 사용자 영역에 수행한다.
- 스레드 교환에 커널이 개입하지 않기에 커널에서 사용자 영역으로 전환이 불필요하다.
  - 커널에서는 스레드 개념이 없으므로 라이브러리를 이용하여 스레드 형태의 실행을 하도록 지원한다. 
#### 장점
- 높은 이식성
  - 기본 커널 변경 없이 모든 운영체제에 적용 가능
- 적은 커널 전환 오버헤드
  - 스케줄링이나 동기화를 통해 커널을 호출하지 않으므로 커널 영역으로 전환 오버헤드가 감소한다.
  - 스레드와 관련된 모든 행위를 사용자 영역에서 실행하기에 커널 영역으로 전환할 필요가 없다.
- 스케줄링의 유연성
  - 스레드 라이브러리에서 스케줄링을 제어하므로 응용 프로그램에 맞게 스케줄링이 가능하다.
#### 단점
- 시스템 동시성을 지원하지 않음
  - 프로세스에 속한 스레드 하나가 대기 상태가 되면 프로세스 전체가 블록되므로 프로세스 준비 상태의 스레드가 있더라도 실행할 수 없다.
  - 운영체제에 스레드 개념이 없어 스레드가 아닌 하나의 프로세스로 보기 때문에 발생하는 문제다.
- 다중 프로세서 시스템 규모 확장 제약
  - 커널이 한 프로세스에 속한 여러 스레드들을 프로세스 하나로 관리하므로 여러 프로세서에 나누어 처리가 불가능하다.
  - 프로세스 하나 당 프로세서 하나를 이용한다. 
- 스레드 간 보호에 커널의 보호 기법 사용 불가
  - 스레드 라이브러리에서 스레드 간 보호를 제공해야 프로세스 수준에서 보호가 가능하다. 

### 커널 수준 스레드(kernel-level-thread)
- 커널이 스레드와 관련된 모든 작업을 수행한다.
- 사용자 스레드마다 하나의 커널 스레드를 매핑하여 일대일 스레드 매핑이다.
- 스레드 관련 모든 작업을 커널이 지원한다.
  - 프로세스와 스레드에 대한 문맥 정보를 커널 영역에 유지하기에 사용자 영역에는 스레드 관리를 위한 코드가 없다.

#### 장점
- 시스템 동시성 지원
  - 프로세스에 속한 스레드 하나가 블록되어도 다른 준비 상태 스레드를 실행할 수 있다.
- 병령 실행을 통한 성능 향상 가능성
  - 다중처리 환경에서 한 프로세스의 여러 스레드가 각각 프로세서를 할당 받아 병렬로 실행하여 성능 향상이 가능하다.
#### 단점
- 스케줄링과 동기화를 위한 커널 호출 오버헤드
  - 커널이 스레드 관리를 담당하기 때문에 커널 호출 오버헤드가 발생한다.
- 사용자 스레드 수에 비례하는 커널 스레드 관리 오버헤드
  - 자원 제한으로 사용자 수준 스레드 생성에 따라 커널 스레드를 무한정 생성할 수 없다.
  - 성능 저하를 막기 위해 커널 스레드 수를 제한해야 한다.
- 낮은 이식성
  - 시스템이 달라지면 해당 운영체제에서 제공하는 스레드 API를 사용해 프로그램을 수정해야 한다.

### 혼합형 스레드
- 사용자 수준 스레드와 커널 수준 스레드를 혼합한 스레드다.
- 여러 사용자 수준 스레드를 한 그룹의 커널 수준 스레드에 다대다(n:m)로 매핑한다.
  - 다대일 스레드 매핑의 동시성 저하 문제 해결
  - 일대일 스레드 매핑의 스레드 수 제한 문제 해결
- 스레드 풀링(thread pooling) 기법을 사용한다.
  - 스레드 풀링: 시스템이 관리하는 스레드 풀을 응용 프로그램에 제공하여 스레드를 효율적으로 사용할 수 있게하는 방법
  - 스레드 풀: 여러 개의 스레드들을 미리 생성하여 모아둔다.
  - 미리 생성한 스레드의 재사용을 통해 스레드 생성 시간을 줄인다.
  - 동시 생성 가능한 스레드 수를 제한한다.

## 스레드의 사용 예
- 워드 편집기 프로세스

- 웹 브라우저 프로세스

- 웹 서버 프로세스
  - 멀티 스레딩으로 처리량과 반응 속도 향상
  - 프로세스는 인터넷을 통해 들어오는 요청을 감지하는 스레드를 하나 포함
  - 여러 클라이언트가 동시에 접근하여 요청하면 각 요청마다 하나의 스레드를 할당하여 서비스

## 멀티 프로세스와 멀티 스레드
### 멀티 프로세스(Multi Process)
하나의 프로그램에서 여러 개의 프로세스를 실행하는 것으로 웹 브라우저의 상단 탭과 새 창이 대표적인 예이다.

#### 장점
  - 여러 개의 자식 프로세스 중 문제가 발생한 프로세스가 있는 경우 해당 자식 프로세스가 죽는 것 이상으로 영향이 확대되지 않는다.

#### 단점
  - 프로세스 생성의 오버헤드
    - 모든 프로세스들은 독립적인 메모리 공간을 가지기에 프로세스 관리를 위한 구조체 생성 및 초기화에 많은 시간이 소요된다.
  - 프로세스 문맥 교환의 오버헤드
    - 프로세스는 각각 독립된 메모리 영역을 할당받기에 프로세스 간의 공유하는 메모리가 없다. 따라서 문맥 교환시 캐시에 있는 모든 모든 데이터를 초기화하고 다시 캐시 정보를 불러와야 한다.
  - 프로세스 사이의 어려운 통신
    - 프로세스는 각각 독립된 메모리 영역을 할당받기에 하나의 프로그램에 속한 프로세스들 간의 변수를 공유할 수 없어 프로세스 간 통신 기법(IPC)을 사용해야한다.

### 멀티 스레드(Multi Thread)
하나의 프로세스에 여러 개의 스레드가 있는 것을 의미하며 하나의 프로그램에서 두 개 이상의 동작을 수행할 수 있게 한다.  
- 멀티 스레드 프로그램은 다중 프로세서 환경이 단일 프로세서 환경보다 실행 속도가 빠르다.
- 스레드들이 하나의 해당 프로세서의 자원을 공유한다.
- 다중 스레드를 이용한 스레드의 생성, 종료, 스레드 간 문맥교환이 다중 프로세스를 이용한 방법보다 빠르다.
- 스레드들은 서로 독립적이지 않아 동일한 프로세스의 모든 스레드들은 해당 프로세스의 모든 주소에 접근이 가능하다.
  - 스레드는 한 사용자가 프로세스 내의 모든 스레드를 소유하므로 스레드들은 서로 협력하는 관계이며 보호 문제는 문제가 되지 않는다.
  - 반면 프로세스의 경우 다수의 사용자에게서 발생하기에 서로 보호가 필요하다.
#### 장점
- 사용자에 대한 응답성 증가
  - 한 스레드가 블록되거나 긴 작업을 수행하더라도 다른 스레드들은 스케줄링되어 실행이 가능하기 때문에 프로그램 전체가 블록되거나 대기해야하는 일이 발생하지 않는다.
- 시스템 자원 활용의 효율성
  - 프로세스에 속한 스레드들은 한 프로세스의 자원을 공유하므로 자원을 할당 받기 위해 시스템 호출을 이용해야하는 프로세스보다 경제적이다.
- 다중 처리를 통한 성능과 효율 향상
  - 다중 프로세서 구조를 활용하여 각 스레드들은 다른 프로세서에서 병렬로 실행이 가능하다. 
  - 프로세스에 속한 스레드들은 자원과 메모리를 공유하므로 같은 주소 공간에서 여러 개의 스레드의 실행을 통해 시스템 성능 향상과 편리함을 제공한다.
- 효율적인 통신
  - 스레드는 Stack 영역을 제외한 모든 메모리 공간을 공유하기에 스레드 간의 통신 비용이 적으며 문맥 교환이 빠르다. 

#### 단점
- 다른 프로세스에서 스레드를 제어할 수 없다.
- 자원 공유로 인해 동기화 문제가 발생한다.
- 오류 발생 가능성이 높으며 재현이 어렵기에 설계에 많은 주의가 요구되며 디버깅이 까다롭다.


> ⬆️:[Top](#프로세스와-스레드)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Operating-System)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [구현회. 운영체제-그림으로 배우는 구조와 원리, 개정3판. 한빛아카데미]
