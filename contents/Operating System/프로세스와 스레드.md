# 프로세스와 스레드
초기 컴퓨터는 하나의 프로그램이 프로세서를 독점했고 프로세스를 통한 관리가 필요하지 않았다.  
하지만 다중 프로그래밍에서 여러 프로그램이 자원을 공유하기에 프로그램들을 제어하는 방법이 요구되었다.  
이에 프로세스를 이용한 프로그램 제어 및 관리를 통해 멀티태스킹 기능을 실현하였다. 

## 프로세스의 개념
프로세스는 메모리에 적재되어 실행되고 있는 프로그램의 인스턴스(독립적인 개체)로 운영체제의 제어를 받는 상태를 의미한다.  
즉, 프로세스는 실행 중인 프로그램의 실행 단위로 볼 수 있다.  
프로그램이 실행되면 메모리에 적재되고 운영체제로부터 시스템 자원(CPU 시간, 주소 공간, 메모리 영역)을 할당 받는다.  
### 프로세스의 주소 공간
프로세스가 실행 중 접근할 수 있도록 허용된 주소의 최대 범위를 말하며, 프로세스의 주소 공간은 CPU 주소 공간과 같다.
#### 프로세스 주소 공간 구조 
프로세스 주소 공간은 사용자 공간과 커널 공간 전체를 포함하며 CPU가 액세스 할 수 있는 전체 공간이 프로세스의 주소 공간이다.

프로세스의 주소 공간에서 힙과 스택 영역의 크기는 정해져 있지 않고, 코드와 데이터를 뺀 나머지 공간을 둘이 합쳐 사용한다.
- 힙: 데이터 영역이 끝난 영역에서 시작하여 주소가 큰 방향으로 커진다.
- 스택: 사용자 주소 공간의 끝에서 주소가 작은 방향으로 커진다.

프로세스는 운영체제에서 설정한 사용자 공간의 최대 범위까지 힙 영역과 스택 영역을 늘려갈 수 있다.

시스템 호출을 통해 커널 공간까지 접근 할 수 있다.

프로세스의 크기와 프로세스 주소 공간 크기는 다르다.
- 프로세스 주소 공간 크기: 프로세스가 액세스 할 수 있는 전체 영역
- 프로세스의 크기: 프로세스가 주소 공간 내에서 현재 사용하고 있는 코드, 데이터, 힙, 스택을 합친 크기

#### 프로세스 주소 공간 구성
- 실행 스택(stack)
  - 호출된 함수(프로시저)의 복귀 주소와 지역 변수 등의 일시적인(함수 실행을 위해 필요한) 데이터를 저장하는 영역
  - 프로세스의 실행 시 사용되는 영역으로, 함수 호출 시 매개변수들과 전역 변수 등을 저장한다.
  - 함수가 종료되면 해당 함수에 의해 할당된 변수들은 메모리에서 해제된다.
  - 함수와 지역 변수 등은 스레드마다 공간을 할당한 Stack구조를 통해 사용이 종료됨에 따라 해제하는 등의 제어가 용이하다.
  - 높은 주소에서 낮은 주소로 할당된다.
  - Stack 메모리 영역을 넘어서 할당되는 경우 Stack Overflow가 발생한다. 
- 실행 힙(heap)
  - 시스템 호출을 통해 동적으로 할당받고 해지하는 등 자유롭게 이용하는 영역으로 런타임에 크기가 결정된다.
  - 주로 참조형 데이터(Class 등)의 데이터가 할당된다.
  - 낮은 주소에서 높은 주소로 할당된다.
  - Heap 메모리 영역을 넘어서 할당되는 경우 Heap Overflow가 발생한다. 
- 데이터(data)
  - 실행 파일 내에 구성된 전역 변수, 정적 변수 등이 저장되는 영역
  - main 함수가 실행되는 동안 메모리 상에 남아있는 변수들을 저장한다.
  - 전역변수 자원을 저장하고 스레드들이 공유하도록하여 효율성을 높인다.
  - 초기화된 데이터 영역(initialized data segment)과 초기화되지 않은 데이터 영역(uninitialized data segment)으로 나뉜다.
- 코드(code)
  - 텍스트 영역이라고도 불린다.
  - 실행 파일 내 구성된 코드들이 적재되는 영역으로 프로그램을 실행시키기 위한 명령문들(제어문, 함수, 상수)이 저장된다.
  - CPU가 해석이 가능한 기계어로 저장되고, 프로그램이 수정되면 안되기에 Read-Only 상태로 저장된다.   

### 프로세스의 종류 
역할과 병행 수행 방법에 따라 구분된다. 
#### 역할에 의한 구분
크게 두 개의 프로세스로 구분되며 두 프로세서 모두 메모리에서 프로그램을 실행한다.  
- 시스템(커널) 프로세스
  - 커널 프로세스 또는 운영체제 프로세스라고 부른다.
  - 모든 시스템 메모리에 접근하고, 모든 프로세서 명령을 실행할 수 있는 프로세스이다.
  - 시스템 운영에 필요한 작업을 수행한다.
- 사용자 프로세스
  - 사용자 코드를 수행하는 프로세스로 시스템 프로세스에 비해 권한이 적다.
  - 자기 자신에게 할당된 공간만 접근 가능하며 특정 프로세서 명령어는 실행이 불가능하다.
    - 시스템에 중요한 영향을 주는 명령어는 실행이 불가능하다.
  - 사용자 프로세스가 실행할 수 없는 프로세서 명령어는 시스템 호출을 통해 처리한다. 

#### 병행 수행 방법에 의한 구분
- 독립 프로세스
  - 여러개의 프로세스가 각자 동시에 실행 되며 병행 프로세스들이 서로 영향을 주고 받지 않는다.
  - 데이터를 공유하지 않는다.

- 협력 프로세스
  - 병행 프로세스들이 서로 영향을 주고 받는다.
  - 제한된 자원을 공유하는 등 서로 협력해야하는 경우 통신을 위한 수단과 동기화 기능이 필요하다.

## 프로세스의 상태 변화
프로세스 상태는 크게 3가지로 분류된다. 
- 실행(running)
  - 프로세서를 점유하여 명령어가 실행되는 상태이다.
- 준비(ready)
  - 프로세서를 할당 받기 위해 기다리는 상태로 실행을 위하단 다른 조건을 갖추고 준비 리스트에서 자신의 차례를 기다린다.
  - 준비 리스트는 큐를 사용한다. 
- 대기(waiting) 또는 보류(blocked)
  - 이벤트(입출력 종료 등 외부 신호) 발생을 기다리는 상태로 장치 별로 대기 큐를 가진다.  

대부분의 프로세스는 준비나 대기(보류) 상태로 존재하며 어느 한 순간에 한 프로세스만 실행 상태로 상태 변화가 일어난다.  
상태 변화는 4가지가 있다. 
#### dispatch(프로세스 이름)
준비 → 실행
- 준비 상태의 프로세스가 프로세서를 할당 받아 실행 상태가 된다.
- 프로세스 스케줄러는 준비 상태인 프로세스 중 하나를 선택하고 디스패처(dispatcher)는 선택된 프로세스에 프로세서를 할당한다.
#### timeout(프로세스 이름)
실행 → 준비
- 실행 상태의 프로세스가 프로세서를 자발적으로 반납하기 전에 할당된 시간이 지나면 해당 프로세스를 준비 상태가 된다.
- 인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 프로세서를 독점하는 것을 방지한다.  
  인터럽트 클록: 프로세스가 프로세서를 할당 받은 후 일정 시간이 지나면 자원의 독점을 막기위해 자동으로 인터럽트를 발생시킨다. 
#### block(프로세스 이름)
실행 → 대기(보류)
- 실행 상태의 프로세스가 자신에게 할당된 시간이 끝나기 전에 어떠한 이벤트가 발생하는 것을 기다려야할 때 스스로 프로세서를 양도하고 대기 상태가 된다.
- 이벤트: 입출력 요청, 새로운 자원 요청 등
#### wakeup(프로세스 이름)
대기(보류) → 준비
- 기다리던 조건이 만족(기다리던 이벤트 발생)되면 대기 상태의 프로세스는 준비 상태가 된다. 

## 프로세스의 관리

### 프로세스 제어 블록

### 문맥 교환 

## 스레드의 개념과 상태 변화

## 스레드의 구현

## 멀티 프로세스와 멀티 스레드

## 멀티 프로세스와 멀티 스레드 비교 


> ⬆️:[Top](#프로세스와-스레드)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Operating-System)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [구현회. 운영체제-그림으로 배우는 구조와 원리, 개정3판. 한빛아카데미]
