# 프로세스와 스레드
초기 컴퓨터는 하나의 프로그램이 프로세서를 독점했고 프로세스를 통한 관리가 필요하지 않았다.  
하지만 다중 프로그래밍에서 여러 프로그램이 자원을 공유하기에 프로그램들을 제어하는 방법이 요구되었다.  
이에 프로세스를 이용한 프로그램 제어 및 관리를 통해 멀티태스킹 기능을 실현하였다. 

## 프로세스의 개념
프로세스는 메모리에 적재되어 실행되고 있는 프로그램의 인스턴스(독립적인 개체)로 운영체제의 제어를 받는 상태를 의미한다.  
즉, 프로세스는 실행 중인 프로그램의 실행 단위로 볼 수 있다.  
프로그램이 실행되면 메모리에 적재되고 운영체제로부터 시스템 자원(CPU 시간, 주소 공간, 메모리 영역)을 할당 받는다.  
프로세스는 실행 중 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성하는데 이 과정에서 부모 프로세스, 자식 프로세스가 생기며 계층 구조를 형성한다.
### 프로세스의 주소 공간
프로세스가 실행 중 접근할 수 있도록 허용된 주소의 최대 범위를 말하며, 프로세스의 주소 공간은 CPU 주소 공간과 같다.
#### 프로세스 주소 공간 구조 
프로세스 주소 공간은 사용자 공간과 커널 공간 전체를 포함하며 CPU가 액세스 할 수 있는 전체 공간이 프로세스의 주소 공간이다.

프로세스의 주소 공간에서 힙과 스택 영역의 크기는 정해져 있지 않고, 코드와 데이터를 뺀 나머지 공간을 둘이 합쳐 사용한다.
- 힙: 데이터 영역이 끝난 영역에서 시작하여 주소가 큰 방향으로 커진다.
- 스택: 사용자 주소 공간의 끝에서 주소가 작은 방향으로 커진다.

프로세스는 운영체제에서 설정한 사용자 공간의 최대 범위까지 힙 영역과 스택 영역을 늘려갈 수 있다.

시스템 호출을 통해 커널 공간까지 접근 할 수 있다.

프로세스의 크기와 프로세스 주소 공간 크기는 다르다.
- 프로세스 주소 공간 크기: 프로세스가 액세스 할 수 있는 전체 영역
- 프로세스의 크기: 프로세스가 주소 공간 내에서 현재 사용하고 있는 코드, 데이터, 힙, 스택을 합친 크기

#### 프로세스 주소 공간 구성
- 실행 스택(stack)
  - 호출된 함수(프로시저)의 복귀 주소와 지역 변수 등의 일시적인(함수 실행을 위해 필요한) 데이터를 저장하는 영역
  - 프로세스의 실행 시 사용되는 영역으로, 함수 호출 시 매개변수들과 전역 변수 등을 저장한다.
  - 함수가 종료되면 해당 함수에 의해 할당된 변수들은 메모리에서 해제된다.
  - 함수와 지역 변수 등은 스레드마다 공간을 할당한 Stack구조를 통해 사용이 종료됨에 따라 해제하는 등의 제어가 용이하다.
  - 높은 주소에서 낮은 주소로 할당된다.
  - Stack 메모리 영역을 넘어서 할당되는 경우 Stack Overflow가 발생한다. 
- 실행 힙(heap)
  - 시스템 호출을 통해 동적으로 할당받고 해지하는 등 자유롭게 이용하는 영역으로 런타임에 크기가 결정된다.
  - 주로 참조형 데이터(Class 등)의 데이터가 할당된다.
  - 낮은 주소에서 높은 주소로 할당된다.
  - Heap 메모리 영역을 넘어서 할당되는 경우 Heap Overflow가 발생한다. 
- 데이터(data)
  - 실행 파일 내에 구성된 전역 변수, 정적 변수 등이 저장되는 영역
  - main 함수가 실행되는 동안 메모리 상에 남아있는 변수들을 저장한다.
  - 전역변수 자원을 저장하고 스레드들이 공유하도록하여 효율성을 높인다.
  - 초기화된 데이터 영역(initialized data segment)과 초기화되지 않은 데이터 영역(uninitialized data segment)으로 나뉜다.
- 코드(code)
  - 텍스트 영역이라고도 불린다.
  - 실행 파일 내 구성된 코드들이 적재되는 영역으로 프로그램을 실행시키기 위한 명령문들(제어문, 함수, 상수)이 저장된다.
  - CPU가 해석이 가능한 기계어로 저장되고, 프로그램이 수정되면 안되기에 Read-Only 상태로 저장된다.   

### 프로세스의 종류 
역할과 병행 수행 방법에 따라 구분된다. 
#### 역할에 의한 구분
크게 두 개의 프로세스로 구분되며 두 프로세서 모두 메모리에서 프로그램을 실행한다.  
- 시스템(커널) 프로세스
  - 커널 프로세스 또는 운영체제 프로세스라고 부른다.
  - 모든 시스템 메모리에 접근하고, 모든 프로세서 명령을 실행할 수 있는 프로세스이다.
  - 시스템 운영에 필요한 작업을 수행한다.
- 사용자 프로세스
  - 사용자 코드를 수행하는 프로세스로 시스템 프로세스에 비해 권한이 적다.
  - 자기 자신에게 할당된 공간만 접근 가능하며 특정 프로세서 명령어는 실행이 불가능하다.
    - 시스템에 중요한 영향을 주는 명령어는 실행이 불가능하다.
  - 사용자 프로세스가 실행할 수 없는 프로세서 명령어는 시스템 호출을 통해 처리한다. 

#### 병행 수행 방법에 의한 구분
- 독립 프로세스
  - 여러개의 프로세스가 각자 동시에 실행 되며 병행 프로세스들이 서로 영향을 주고 받지 않는다.
  - 데이터를 공유하지 않는다.

- 협력 프로세스
  - 병행 프로세스들이 서로 영향을 주고 받는다.
  - 제한된 자원을 공유하는 등 서로 협력해야하는 경우 통신을 위한 수단과 동기화 기능이 필요하다.

## 프로세스의 상태 변화
프로세스 상태는 크게 3가지로 분류된다. 
- 실행(running)
  - 프로세서를 점유하여 명령어가 실행되는 상태이다.
- 준비(ready)
  - 프로세서를 할당 받기 위해 기다리는 상태로 실행을 위하단 다른 조건을 갖추고 준비 리스트에서 자신의 차례를 기다린다.
  - 준비 리스트는 큐를 사용한다. 
- 대기(waiting) 또는 보류(blocked)
  - 이벤트(입출력 종료 등 외부 신호) 발생을 기다리는 상태로 장치 별로 대기 큐를 가진다.  

대부분의 프로세스는 준비나 대기(보류) 상태로 존재하며 어느 한 순간에 한 프로세스만 실행 상태로 상태 변화가 일어난다.  
상태 변화는 4가지가 있다. 
#### dispatch(프로세스 이름)
준비 → 실행
- 준비 상태의 프로세스가 프로세서를 할당 받아 실행 상태가 된다.
- 프로세스 스케줄러는 준비 상태인 프로세스 중 하나를 선택하고 디스패처(dispatcher)는 선택된 프로세스에 프로세서를 할당한다.
#### timeout(프로세스 이름)
실행 → 준비
- 실행 상태의 프로세스가 프로세서를 자발적으로 반납하기 전에 할당된 시간이 지나면 해당 프로세스를 준비 상태가 된다.
- 인터럽트 클록(interrupt clock)을 두어 특정 프로세스가 프로세서를 독점하는 것을 방지한다.  
  인터럽트 클록: 프로세스가 프로세서를 할당 받은 후 일정 시간이 지나면 자원의 독점을 막기위해 자동으로 인터럽트를 발생시킨다. 
#### block(프로세스 이름)
실행 → 대기(보류)
- 실행 상태의 프로세스가 자신에게 할당된 시간이 끝나기 전에 어떠한 이벤트가 발생하는 것을 기다려야할 때 스스로 프로세서를 양도하고 대기 상태가 된다.
- 이벤트: 입출력 요청, 새로운 자원 요청 등
#### wakeup(프로세스 이름)
대기(보류) → 준비
- 기다리던 조건이 만족(기다리던 이벤트 발생)되면 대기 상태의 프로세스는 준비 상태가 된다. 

## 프로세스의 관리
### 프로세스 제어 블록(PCB: Process Control Block)
- 운영체제가 각 프로세스를 관리하기 위해 필요한 정보(메타 데이터)를 저장해두는 자료 구조로 하나의 PCB에 하나의 프로세스 정보가 담긴다.
- 커널 시스템은 하나의 프로세스 테이블을 통해 모든 프로세스를 관리하며 프로세를 생성할 떄마다 PCB를 생성하여 프로세스 정보를 저장한다.
- 프로세스 테이블의 비어있는 항목에 PID(프로세스 번호)와 함께 PCB를 연결하고 PID로 프로세스를 구분한다.
- 작업 제어 블록(Task Control Block)이라고도 불린다.

#### PCB의 생성과 제거
- 생성
  - 프로세스가 생겨나고 프로세스 주소 공간에 코드, 데이터, 스택 공간이 생성된 후 PCB가 생성되며 프로세스 정보가 저장된다.
  - 생성된 PCB는 메인 메모리에 유지된다.
- 제거
  - 프로세스가 종료되면 같이 제거된다.
 
#### PCB에 저장되는 프로세스의 정보
- 프로세스 식별자(Process ID): 프로세스 고유 식별 번호
- 프로세스 상태(Process State): 프로세스의 현재 상태 정보((create), 준비(ready), 실행(running), 대기(waiting), 완료(terminated))
- 프로그램 카운터(Program Counter): 프로세스가 다음에 실행할 명령어의 주소
- 레지스터 저장 영역: 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터, 조건 코드 등 정보  
   - 인터럽트 발생 시 프로그램 카운터와 함께 저장하여 재실행 시 원래대로 복귀할 수 있도록 한다.
- 프로세서 스케줄링 정보: 프로세스의 우선순위, 스케줄링 큐의 포인터, 기타 스케줄 매개변수, CPU 점유시간 등 정보
- 메모리 관리 정보: 프로세스의 주소 공간, 페이지 테이블, 세그먼트 테이블 등 메모리 관리 시스템 정보
- 프로세스 계정 정보: 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등 프로세스 정보 
- 입출력 상태 정보: 특별한 입출력 요구 프로세스에 할당된 입출력 장치, 열린 파일 리스트 등에 관한 정보

#### PCB가 존재하는 이유 
인터럽트를 통해 여러 프로세스를 실행하는 경우, 유실된 정보 없이 실행하기 위해 대기 중인 프로세스의 직전 정보와 상태를 저장하는 프로세스 제어 블록이 필요하다.   
커널은 현재 CPU가 실행 중인 프로세스를 중단 시키고 다른 프로세스를 실행할 때, 현재 프로세스가 실행 중인 상황 정보를 PCB에 저장한다.

#### 프로세스 스케줄링
- 연결리스트 방식으로 관리하여 삽입 및 삭제가 용이하다.
- PCB List Head에 PCB가 생성될 때마다 이어지게 만든다.
- 프로세스가 생성되면 Ready Queue에 삽입되지만 실제로는 PCB가 연결리스트로 연결되어 있다.

### 프로세스 생성
운영체제 또는 다른 프로세스의 요청에 의해 프로세스가 생성된다.  
- 프로세스의 생성 과정
  1. 새로운 프로세스에 프로세스 식별자 할당
  2. 프로세스의 주소 공간과 프로세스 제어 블록 할당
  3. 프로세스 제어 블록 초기화
  4. Ready Queue에 삽입
- 자원 할당
  - 자식 프로세스에게 필요한 자원을 운영체제가 직접 할당
  - 자식 프로세스가 부모 프로세스의 자원 일부 사용
- 실행 방식
  - 부모 프로세스와 자식 프로세스가 동시에 실행
  - 부모 프로세스는 자식 프로세스들이 모두 종료할때까지 기다린다
- 주소 공간
  - 동일 작업을 수행할 경우 자식 프로세스가 부모 프로세스의 주소 공간을 복사
  - 다른 작업을 수행할 경우 자식 프로세스가 별도의 프로그램을 적재
### 프로세스 종료
프로세스가 마지막 명령을 실행하면 종료하여 운영체제에 프로세스 제거를 요청하며 부모 프로세스가 자식 프로세스를 종료할 수 있다.  
이 경우 부모 프로세스가 abort(중단) 시스템을 호출하여 자식 프로세스를 종료한다.  
보통 부모 프로세스를 종료하면 운영체제가 자식 프로세스도 종료하는데 이를 연속 종료라고 한다. 
- 프로세스 종료 이유
  - 정상 종료
  - 명시된 전체 시간 초과
  - 실패: 파일 검색 실패, 입출력 실패 등
  - 오류 발생
  - 메모리 부족, 접근 위반 등
### 프로세스 제거
프로세스 종료 후 프로세슬르 파괴하는 과정으로 프로세스가 점유하고 있던 자원을 시스템에 반납하고 해당 프로세스가 시스템 리스트나 테이블에서 제거된다.(PCB 제거)  
부모 프로세스를 제거하면 자식 프로세스도 같이 제거된다.  
프로그램은 여전히 디스크에 저장되어 있다. 

### 프로세스 중단(suspend)과 재시작(resume)
프로세스의 상태 변화에 중단과 재시작이 추가된 상태 변화로 보조기억장치에 우선순위가 낮은 프로세스를 이동시켰다가 활동 시 다시 메인 메모리로 복귀시킨다. 
- 중단과 재시작을 추가한 프로세스의 상태 변화
- 두 가지의 중단 상태
  - 중단된 대기(suspended waiting): 프로세스가 보조기억장치에 있으면서 이벤트를 대기 중인 상태
  - 중단된 준비(suspended ready): 프로세스가 보조기억장치에 있지만 즉시 메인 메모리로 로드하여 실행할 수 있는 상태
- 프로세스 중단과 재시작 발생 상황
  - 시스템 부하 조정이 필요할 때
  - 시스템 기능 장애가 발생할 때
  - 프로세스의 일부분이 의심스러울 때
  - 주기적 프로세스가 다음 실행을 기다릴 때
  - 부모 프로세스가 자식 프로세스를 조사 또는 수정하여 활동을 재조정할 때
### 프로세스 우선순위 변경 
프로세스는 서로 다른 우선순위를 가질 수 있으며 프로세스 스케줄러는 PCB에 기록된 우선 순위를 이용하여 Ready Queue의 프로세스를 처리한다.
- 우선 순위 구분
  - 프로세서 중심 프로세스(CPU-bound process)
    - 주로 CPU를 이용한 연산이 많으며 입출력이 적다.
    - 프로세서를 한 번 차지하면 오래 사용하는 경향이 있다.
    - 시간 할당량을 길게하여 프로세서 사용 횟수를 줄이고 한 번에 오래 사용한다.
    - 낮은 우선순위가 부여된다.
  - 입출력 중심 프로세스(I/O-bound process)
    - CPU의 사용은 적고 입출력을 자주 받는다.
    - 프로세서를 한번 차지하면 짧게 사용하는 경향이 있다.
    - 높은 우선순위가 부여된다.

### 문맥 교환
원래 실행중이던 프로세스의 정보를 PCB에 저장하고, 바뀌는 프로세스의 정보를 PCB에 저장된 내용을 토대로 레지스터에 적재하여 프로세스를 교환하는 과정이다.  
여러 프로세스를 동시에 수행하는 것처럼 보이게 하기 위해 사용되며 운영체제 설계시 불필요한 문맥 교환을 줄이는 것이 주요 목표이다. 
- Why? 문맥 교환은 시간과 비용이 들어가는 오버헤드로 자주 일어나는 경우 시스템 전체 성능 저하가 발생할 수 있다.  
  오버헤드: 어떤 처리를 위해 소모되는 간접적인 처리 시간 메모리 등을 뜻하며 메모리 속도, 레지스터 수, 특수 명령어의 유무에 따라 오버헤드가 다르다.

- 사용자 모드에서 커널 모드로 넘어와 수행하는 것들이 오버헤드에 해당한다.

#### 문맥 교환이 발생하는 경우
  - 인터럽트
    - 입출력 인터럽트: 입출력 관련 인터럽트로 입출력 완료에 의해 발생 
    - 클록 인터럽트: CPU가 특정 프로세스에 집중적으로 사용이 안되도록 관리(Timeout)
    - 트랩(trap): 소프트웨어적 인터럽트로 부정적 파일 접근 또는 실행중인 프로세스의 오류나 예외 상황으로 인해 발생
  - 프로세스의 선점시간이 종료되는 경우
  - 입출력 등 특정한 이벤트를 위해 대기하는 경우 


## 스레드의 개념과 상태 변화

## 스레드의 구현

## 멀티 프로세스와 멀티 스레드

## 멀티 프로세스와 멀티 스레드 비교 


> ⬆️:[Top](#프로세스와-스레드)
> ⬅️:[Back](https://github.com/Minho979/CS_Study/blob/main/README.md#%EF%B8%8F-Operating-System)
> 💁:[Home](https://github.com/Minho979/CS_Study/blob/main/README.md)
> - Reference
> - [구현회. 운영체제-그림으로 배우는 구조와 원리, 개정3판. 한빛아카데미]
